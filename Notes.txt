======================NODE JS===========================================
- JavaScript is mostly executed on a single thread in Node.js and in the browser (with some exceptions such as worker threads)
 - // CommonJS, every file is module (by default)
 - // Modules - Encapsulated Code (only share minimum)
 - // GLOBALS  - NO WINDOW !!!!

// __dirname  - path to current directory
// __filename - file name
// require    - function to use modules (CommonJS)
// module     - info about current module (file)
// process    - info about env where the program is being executed
------------Modules vs Framework-------------------------
- Modules : Node.js follows the CommonJS module system, where each file is treated as a module. Modules can export functions, objects, or variables that can be used in other modules.
    - modules are not structred like two modules are not created to provide certain set of facilities in standard way. they are developed as a purpose of reusibility of the code.
- Framework : A framework, on the other hand, is a higher-level abstract
ion that provides a structured way to build and organize an entire application. It often includes predefined patterns, conventions, and functionality to help developers create applications more efficiently. Eg: Express
-------------------------------------

    - Node. js provides the facility to get process information such as process id, architecture, platform, version, release, uptime, cpu usage etc. It can also be used to kill process, set uid, set groups, unmask etc. The process is a global object, an instance of EventEmitter, can be accessed from anywhere.
 - there is no browser in the Nodejs as this is backend runtime environment so there will be no browser and document in here
 - node uses the CommonJS, every file in node is a module
 - if you want to expose some property from one module than we use the 'module.export'
 - if you want to import some property from other module than we use 'require'
 - Q. can't we just import/require only function from the module rather than import/require whole property from the module.


 -------------Built-in-modules-------------------
 Built-in modules: these are some , actual list is numerous modules
- OS 
    - get the information about the OS
    - type
- PATH 
    - since the project is deployed in the different environment than directory str. can be different and we might need to access some modules than PATH module helps to reach and find the path.
- FS - file structre : 
    - require('fs')
    - async :
        - const { readFile, writeFile,appendFile } = require('fs') => three parameter
            - path of file, content, callback function for err and result handling
    - sync
        - const { readFileSync, writeFileSync } = require('fs') -> three param
            - path of file, content,  { flag: 'w'/'a' } -> a = append, w = override
    - In both async and sync it will create file if not present
    - In both the cases of writeFileSync -> it will create the fill if it does not exist and 3rd param is the mode : 'a' -> append, 'w' -> write. And for 'a' -> it will append into file and for 'w' it will override.
    - By default - 'w'
- HTTP : 
    - require('http')
    - createServerInstance = httpinstanc.createServer((req,res) =>{//logic of req.url -> handling for each page; and end the reponse with res.end('<response ends>')})
    - createServerInstance.listen(portname)
    - and then go to chrome and localhost:portname
-------------npm-------------------
npm :

===================about npm======================
In simple terms, npm (Node Package Manager) is like a giant online store for developers who are building websites or applications using JavaScript. Just like how you might go to a store to buy ingredients for cooking, developers use npm to find and download different packages (or pieces of code) that help them build their projects more efficiently.

In addition to helping developers find and manage packages, npm also provides tools for developers to share their own code with others. So, if you've come up with a really useful piece of code, you can publish it to npm for other developers to use in their projects. It's like sharing your favorite cake recipe with friends so they can bake it too!

======================================================
npm - global command comes with node
npm --version

local dependency - use it only in this particular object
npm i <packageName>


global dependency - use it in any project
npm install -g <packageName>
sudo npm install -g <packageName> {mac}
------------------package.json----------------------
package.json and npm
 - whenever we are installing any packing or creating any package we start by the command npm init -> which ask about the package.json content so that for the project it can save all the metadata of the package.
 - directly create the packge.json ---command--> npm init -y
 - most imp use of the package.json is storing dependency that is require to install the package, which the packge is using
- if you install a npm package and it has dependency like while installing boostrap it required jquery as well, so in package.json it will only show the bootsrap as the dependency but it will also install jquery in the node-modules folder.
- IMPORTANT :
    - so all the dependency are not pushed on github
    - .gitignore : dependency are mentioned in the package, using .gitignore we ignore the node-modules package and then it will only push the changes
    - 'npm install' : when someone clone repo than package.json has the dependency in it they need to run the command : 'npm install', it will install all the dependencies

--------------------nodemon--------------------------
nodemon and npx
nodemon : automate the process of restarting your Node.js application when code changes are detected.

npx : npx is a package runner tool that comes with npm (Node Package Manager) starting from version 5.2.0. It allows you to execute Node.js packages directly, without having to install them globally or add them as project dependencies. The name "npx" stands for "Node Package eXecute.

-------------------package-lock-------------------------------
package-lock.json
 - sometimes the dependencies have there own dependencies and pacakge.json doesnt mention them, so package-lock.json have the detail of all the dependencies and there version so that while installing the package user have the same version of all the related dependencies which are used or inherited in the package.

 --------------------event loop-----------------------------
 event loop : 
 So, the event loop in Node.js is like an efficient chef in a busy kitchen, making sure that your application handles multiple tasks without getting stuck, resulting in a responsive and performant application.

console.log('first')
setTimeout(() => {
	console.log('second')  
},0)
console.log('third')


output :this same behaviour is presnt in the normal JS as well
first
third
second

-- now what happens in this case if there is any operation in the async block of code which is taking lot of time, so it will halt the other server calls as well until the operations get successfully completed. 
refer :  01-node-tutorial\2-async-patterns\1-block.js
-- What is promise ? is Promise is async in JS?
Ans: Promises themselves are not inherently asynchronous.they are often used to work with asynchronous operations. used to represent the eventual completion (or failure) of an asynchronous operation. allows you to write non-blocking code and handle the results when they are ready.


- const { readFile, writeFile } = require('fs').promises
- const util = require('util')
- const readFilePromise = util.promisify(readFile)
- const writeFilePromise = util.promisify(writeFile)
These are the ways you can directly get the promise of the async methods 

----------------------Events-------------------------------------------
Events infor :
 - nodejs is event driven programming language
 - even it is server side it is heavily used
 - 'on' : listen for an event
 - 'emit' : emit an event
 - const EventEmitter = require('events') //return class/module
 const obj = new EventEmitter()
 obj.on('eventname', () => {
    //task
 })
 obj.emit('eventname')

 -----------------event emitter-----------------------------
 Using event emitter in Streams :
  -HTTP server creation also works on event
     - they have various event name which can be handled 
     /* 
     const server = http.createServer()
     server.on('request',(req,res) => {
        res.end('Request end')
     })
     */
 - const stream = fs.createReadStream('./content/big.txt')
 stream.on('data', (result) => { 
    log-> data
 })
 - read data in chunk using createReadStream
 - same applies when you are using the createReadStream -> inside the HTTP 
const fileStream = fs.createReadStream('./content/big.txt', 'utf8') 
 fileStream.on('open', () => {
      fileStream.pipe(res)
    })
 - now this pipe method let us write data in chunk in response

======================EXPRESS JS===========================================
middleware in web applications is a powerful and flexible tool that helps you manage the request-response cycle, enhance security, improve code organization, and facilitate extensibility and maintainability. It's a fundamental concept in web development that contributes to the robustness and functionality of modern web applications.
Express js helps to create a middleware, in simpler terms it is an class where there are some extra checks and conditions are present before processing request to the server, it also protect server from direct access.
NOTE : THESE ARE JUST CLASSES WHICH ARE BEING NAMED THE {FRONT END, MIDDLEWARE, SERVER}

Express : it is built over the Node and HTTP module, so it is not like you can use Express without using Node. 
Q. why do we need express instead of directly using http module ?
ans : 

request : In request we hit a remote addr so what is after ':' explained below 
Remote Address : [54.237.133.81]:{443} => [...]-> this is building Address, {443} -> exact flat number inside that building, so all the flats in that building has same address just each flat has diff flat number inside the building.


Ports : specific ports have some specific task, like department in a company.
eg : 80 : for HTTP all WWW request comes through this.

---------------Headers : setHead and writeHead------------------
setHead : sets a single header.
writeHead : set multiple headers at once.
writeHead() takes precedence over setHeader() if both are used in the same request.
res.writeHead(StatusCode, {})
res.writeHead(200,{
        'content-type' : 'text/html'//mime type : Multipurpose Internet Mail Extensions
    })
res.write(<file name>); // send the body of the response

--------------------Express------------------
http(status,get)->params(:/id)->query(?search=doe)->middleware(req,res,next)->http methods->router
Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. Express itself is developed using JavaScript and is built on top of Node.js, which is a server-side JavaScript runtime.
- handle HTTP requests, manage routes, and perform various server-side tasks.
 - Expres is not a built-in module of Nodejs
 - Q. why do we need express?
 - Ans : as you see in 01-http-basics and 02-http-app how hectic it is to call and handle each request of the http and for large project it will be really inefficient and hectic process to follow the http and use its method directly. so the Express was introduced to solve this issue and to make life of a developer easier.
  - $ npm install express --no-save : To install Express temporarily and not add it to the dependencies list:


  -------Code-----
  const express = require("express");
  // app.get
// app.post
// app.put
// app.delete
// app.all
// app.use
// app.listen
app.all('*', (req, res) => {
  res.status(404).send('<h1>resource not found</h1>')
})
app.get('/', (req, res) => {
  console.log('user hit the resource')
  res.status(200).send('Home Page')
})
-----------------------------------
app.use(express.static('./public'))
now this is a middleware function that actually setup the filename present inside the folder public, you can name folder anything. So you don't need to get all the Address of the files like css, js, img, svg they all will be covered under this.

---------------------------------------- 
rather then sending the html file in the response we will see the two ways to expose a directly to the browser so that we don't need to provide the individual files to the response.

1) Using the static asset : SSR (server side rendering)
Many web servers and web frameworks automatically look for a file named 'index.html'.Many web servers and web frameworks automatically look for a file named index.html
 //app.use(express.static('./methods-public')) : this actually make a repo public

2) Using the API :
in this way server only handles the request and response from the client and then only send the json from the server. not like the SSR where we were sending the template from the server or making the directory public, so that client can render in. 


------------------------------------------
API : handing the req from the browser/client :
app.get('/', (req, res) => {
  res.json(products)
})
//products is the json formatted data 
// insted one can also use res.send(products) to send the response, as we were doing previously


#extra :
    - using MAP in JavaScript:
        - products = it is an json where nodes are id,name,image
        -   const prodMap = products.map((product)=> {
                const {id,name,image} = product;
                return {id,name,image}
            })
    - map method do nothing but to iterate over the json and then convert the required json into the map
     - so more appropriate task is to convert the whole json into the map so that when we are sending the response than on client end user can directly handle the map and only the required attribute can be send to client so that data trnasfer can be minimal and client side can remain lightweight
Query params:
The colon (:) in the Express framework is used to indicate a parameter in a route. For example, the route /users/:id tells Express that the id parameter is expected in the route. This parameter can then be accessed in the request object using the req.params property.

- Route parameter :
    - /:productID : this lets the JS know about about the param which will be present in the URL
    -   const {productID}  = req.params //gives the parameter from URL
    -   const param  = req.params //gives the whole object
        console.log(param);// {product : 1}
        console.log(product); //1


- Query :
    - http://localhost:5000/api/v1/query?search=albany&limit=2
    - in the above url after v1 everything is called query parameter.
    - to access query param :
        - In get method of the express : 
            `
            const {search,limit} = req.query
            `
- NOTE : YOU CANNOT SEND TWO RESPONSE IN SAME REQUEST , EXPRESS THROW ERROR FOR THIS. so always use return to send the response.



-----------Middleware----------------
- it is just another class. a set of code that comes before the database.
- middleware are the function that execute during the request of the server.
- whatever happens betweent the request and response is the middleware
- //  req => middleware => res
- req,res,next() -> these three things are there in the middleware function and the most important thing is to end the middleware function by providing either the end of the req-res cycle or passing the baton of middleware function to another middleware function using the next()
- it is better to create a different file for the middleware function and export them from the file and to use them in the specified class use app.use('<url pattern for which to use middleware fn>', imported file)
- the order of app.use in file matters, app.use will only be called for the statements after the app.use
- if you want to use the middleware for specific url than 
    app.use(<mention the URL for which specific middleware should be used>, )
- inside the app.use([midd1,midd2]) -> order of midd1 and midd2 also matters, midd1 called first and midd2 then second
----------------------
http methods :

-------get---------
app.get('/api/people',(req,res) =>{
    res.status(200).json({success:true, data:people})
})
- it is by default setup by the browser.
- to get the data in case of get request one need to provide in URL as form of param or query. whereas in post we can pass it in body and then from express.urlencoded we can use the body that is present in the request.
-------post-----change to db---
app.post('/api/postman/people',(req,res) => {
    const {name} = req.body
    if(!name) {
        return res.status(400).json({success:false, msg:"please provide name value"})
    }
    else {
        return res.status(200).json({success:true, data:[...people,{'id':people[people.length-1].id+1,'name':name}]})
    }
})
NOTE : always use the return statement when you are sending the respons. otherwise you will get 'Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client'
- so this is the type of http method which let us make changes in the database.
- before accessing the data in the request in the post reqest, we need to use a middleware that will make changes to the request so that we can access the body part of the request. 
- app.use(express.urlencoded({extended : false})) - see the documentation in express doc. 
- the above middleware helps us to directly access the request body. req.body
- Content-Type: application/x-www-form-urlencoded : 
- Now in the <02-express-tutorial\methods-public\index.html> file we were sending the post request from the html only so the content is 'application/x-www-form-urlencoded'
- Next, we will be sending request from the javascript so the content-type would be different.


-------put-------update----
www.dns.com/api/orders/:id -> update a specific order (params + send data) 
- 
app.put('/api/postman/people/:id',(req,res)=>{
    const {id} = req.params
    const {name} = req.body
    if(id && name) {
        people.forEach((element,index) => {
            if(element.id==id) {
                element.name = name
            }
        });
       return res.status(200).json({success:true, data:[...people]}) //always return the response if there is response present after this response.
    }
    else {
        res.status(400).json({success:false, msg:"Id or Name is missing"})
    }
})
 - to update the database

---------------------
Express routing : https://expressjs.com/en/guide/routing.html
must read document to know about routing in express





------------------------------------------